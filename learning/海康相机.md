# 海康相机

## 一，安装MVS

官网下载对应版本

图形化界面位置

```shell
cd /opt/MVS/bin
./MVS
```

## 二，使用opencv打开相机

将MVS目录下的include和lib文件夹复制到项目文件夹内，与main.cpp同级

编辑CMakeLists.txt   

确保提前安装好-lX11

```cmake
# cmake needs this line
cmake_minimum_required(VERSION 3.1)
set(PROJECT_NAME1 "camera_class_project")
# Define project name
#set(CMAKE_BUILD_TYPE "Debug")
set(CMAKE_BUILD_TYPE "Release")
set(PROJ_DIR "/home/qiyao/codes/camera_class")#是目录，不是文件
#s设置自己的项目文件夹目录，用以定位文件夹下的include'和lib

project(${PROJECT_NAME1})
find_package(OpenCV REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})
message(STATUS "OpenCV library status:")
message(STATUS "    config: ${OpenCV_DIR}")
message(STATUS "    version: ${OpenCV_VERSION}")
message(STATUS "    libraries: ${OpenCV_LIBS}")
message(STATUS "    include path: ${OpenCV_INCLUDE_DIRS}")

link_directories("${PROJ_DIR}/lib/64")
include_directories("${PROJ_DIR}/include" "/usr/include/X11" "/usr/include")
link_libraries("${PROJ_DIR}/lib/64/libMvCameraControl.so")
add_compile_options(-std=c++11)
add_executable(${PROJECT_NAME1} main.cpp)
add_library(camera_class SHARED camera_class.cpp)
#target_link_libraries(${PROJECT_NAME1} PUBLIC )

# Link your application with OpenCV libraries
target_link_libraries(${PROJECT_NAME1} ${OpenCV_LIBS} )
target_link_libraries(${PROJECT_NAME1}  -lX11)
target_link_libraries(${PROJECT_NAME1} libMvCameraControl.so)
target_link_libraries(${PROJECT_NAME1} camera_class)

```

## 三，编辑相机class

camera_class.h

```c++
#ifndef CAMERA_CLASS_H_INCLUDED
#define CAMERA_CLASS_H_INCLUDED
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include "MvCameraControl.h"
#include <iostream>
#include "opencv2/core.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include <opencv2/video/video.hpp>
using namespace std;
using namespace cv;

class camera{
private:
    void* handle;//相机句柄
    bool g_bExit;//退出标志
    int nRet;//返回值
    unsigned int g_nPayloadSize;//图像数据大小
    unsigned char *pDataForRGB;//存储RGB图像数据的缓冲区
    MV_CC_DEVICE_INFO* pDeviceInfo;//设备信息指针
    MV_CC_DEVICE_INFO_LIST stDeviceList;//设备列表
    MVCC_INTVALUE stParam;//参数结构体
    MV_FRAME_OUT stOutFrame;//输出帧
    MV_CC_PIXEL_CONVERT_PARAM CvtParam;//像素转换参数
public:
    camera();//构造函数，用于初始化相机
    void PrintDeviceInfo();//打印相机信息，如名称等
    void close_cam();//关闭相机
    void start_cam();//打开相机
    void get_pic(Mat * srcimg);//获取图像，将图像信息存储到指定的mat中
    void re_iso();//重新设置曝光参数
};
#endif // CAMERA_CLASS_H_INCLUDED

```

camera_class.cpp
```c++
#include "camera_class.h"
camera::camera()
{
    nRet = MV_OK;
    handle = NULL;
    g_bExit = false;
    g_nPayloadSize = 0;
    pDataForRGB  = (unsigned char*)malloc(1280 *960 * 4 + 2048);
    memset(&stParam, 0, sizeof(MVCC_INTVALUE));
    CvtParam={0};
    stOutFrame = {0};
    memset(&stOutFrame, 0, sizeof(MV_FRAME_OUT));
}
void camera::start_cam()
{

    memset(&stDeviceList, 0, sizeof(MV_CC_DEVICE_INFO_LIST));
    nRet = MV_CC_EnumDevices(MV_GIGE_DEVICE | MV_USB_DEVICE, &stDeviceList);
    if (stDeviceList.nDeviceNum > 0)
    {
        for (unsigned int i = 0; i < stDeviceList.nDeviceNum; i++)
        {
            pDeviceInfo = stDeviceList.pDeviceInfo[i];
            if (NULL == pDeviceInfo)
            {
                break;
            }
            PrintDeviceInfo();
        }
    }else{
        cout<<"Find no Device"<<endl;
    }
    unsigned int nIndex = 0;
    MV_CC_CreateHandle(&handle, stDeviceList.pDeviceInfo[nIndex]);
    MV_CC_OpenDevice(handle);
    if (stDeviceList.pDeviceInfo[nIndex]->nTLayerType == MV_GIGE_DEVICE)
    {
        int nPacketSize = MV_CC_GetOptimalPacketSize(handle);
        if (nPacketSize > 0)
        {
            MV_CC_SetIntValue(handle,"GevSCPSPacketSize",nPacketSize);
        }else{
            cout<<"Warning: Get Packet Size fail"<<endl;
        }
    }
    MVCC_ENUMVALUE  p={0};
    MVCC_STRINGVALUE st;
    MV_CC_GetStringValue(handle,"DeviceModelName",&st);
    cout<<"DeviceModelName: "<<st.chCurValue<<endl;
    MV_CC_GetStringValue(handle,"DeviceVersion",&st);
    cout<<"DeviceVersion:\t"<<st.chCurValue<<endl;
    MV_CC_GetEnumValue(handle,"DeviceScanType",&p);
    if(p.nCurValue==0)
    {
        cout<<"DeviceScanType:\t"<<"Areascan"<<endl;

    }else{
        cout<<"DeviceScanType:\t"<<"Linescan"<<endl;
    }
    MV_CC_SetEnumValue(handle, "TriggerMode", 0);
    MV_CC_SetEnumValue(handle, "PixelFormat", 0x0210001F);
    MV_CC_SetEnumValue(handle, "GainAuto", 1);
    MV_CC_SetFloatValue(handle, "Gamma", 0.8);
    MV_CC_SetBoolValue(handle, "GammaEnable", 1);
    MV_CC_SetEnumValue(handle, "BalanceWhiteAuto", 2);
    MV_CC_SetEnumValue(handle, "ExposureAuto", 1);
    MV_CC_GetIntValue(handle, "PayloadSize", &stParam);
    g_nPayloadSize = stParam.nCurValue;
    nRet = MV_CC_StartGrabbing(handle);
    if (MV_OK == nRet)
        cout<<"Start Grabbing !"<<endl;
    cout<<"\nPress ESC to exit.\n";
}
void camera::PrintDeviceInfo()
{
    if (NULL == pDeviceInfo)
    {
        cout<<"null point"<<endl;
    }
    if (pDeviceInfo->nTLayerType == MV_GIGE_DEVICE)
    {
        int nIp1 = ((pDeviceInfo->SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24);
        int nIp2 = ((pDeviceInfo->SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16);
        int nIp3 = ((pDeviceInfo->SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8);
        int nIp4 = (pDeviceInfo->SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff);
        cout<<"IP:"<<nIp1<<".camera_class.cpp"<<nIp2<<"."<<nIp3<<"."<<nIp4<<endl;
    }
}
void camera::close_cam()
{
    int nRet = MV_CC_StopGrabbing(handle);
    if (MV_OK == nRet)
        cout<<"Stopped Grabbing !"<<endl;
}
void camera::get_pic(cv::Mat* srcimg)
{
    MV_CC_GetImageBuffer(handle, &stOutFrame, 400);
    CvtParam.enSrcPixelType=stOutFrame.stFrameInfo.enPixelType;
    CvtParam.enDstPixelType=PixelType_Gvsp_RGB8_Packed;
    CvtParam.nHeight=stOutFrame.stFrameInfo.nHeight;
    CvtParam.nWidth=stOutFrame.stFrameInfo.nWidth;
    CvtParam.nDstBufferSize=stOutFrame.stFrameInfo.nWidth * stOutFrame.stFrameInfo.nHeight *  4 + 2048;
    CvtParam.pSrcData=stOutFrame.pBufAddr;
    CvtParam.pDstBuffer=pDataForRGB;
    CvtParam.nSrcDataLen=stOutFrame.stFrameInfo.nFrameLen;
    MV_CC_ConvertPixelType(handle,&CvtParam);
    *srcimg=Mat(stOutFrame.stFrameInfo.nHeight,stOutFrame.stFrameInfo.nWidth,CV_8UC3,pDataForRGB);
    cvtColor(*srcimg,*srcimg,COLOR_RGB2BGR);
    if(NULL != stOutFrame.pBufAddr)
    {
        MV_CC_FreeImageBuffer(handle, &stOutFrame);
    }
}
void camera::re_iso()
{
    MV_CC_SetEnumValue(handle, "BalanceWhiteAuto", 2);
    MV_CC_SetEnumValue(handle, "ExposureAuto", 1);
}
```

## 四，在主函数中打开相机

```c++
#include <stdio.h>
#include "opencv2/core.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include <opencv2/video/video.hpp>
#include <opencv2/opencv.hpp>
#include "camera_class.h"

int main()
{
    Mat img;
    int key;
    camera cam;
    cam.start_cam();
    while(1)
    {
        cam.get_pic(&img);//img为每帧
        imshow("test",img);
        key=waitKey(1);
        if(key==27)
        {
            cam.close_cam();
            break;
        }

    }
    return 0;
}
```



